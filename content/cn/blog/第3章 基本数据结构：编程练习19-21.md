---
source: Python 数据结构与算法分析(第2版)
title: 第3章 基本数据结构：编程练习19-21
tags: [ 书籍, python]
date: 2023-03-04
lastmod: 2023-03-27 
thumbnail: https://thumbsnap.com/i/AdjDN43H.jpg
published: "true"
---


## 1 编程练习19
### 1.1 要求
实现UnorderedList 类的 slice 方法。该方法接受 start 和 stop 两个参数，并且返回一个从 start 位置开始，到 stop 位置结束的新链表(但不包含 stop 位置上的元素)。
当 stop 没有值或者小于等于 start 时，为 UnorderedList 类的取值功能。可以将 stop 的默认值设为 0。
### 1.2 思路
首先遍历链表，找到 start 位置，然后继续遍历，直到 stop 位置。因为不能改变原链表，新链表必须新建节点，节点内容等于原链表相应的节点，这样新链表的最后一个节点的 next 等于 None，不改变原链表的相应节点的 next 。
### 1.3 流程图
```plantuml
@startuml   
    skinparam conditionStyle InsideDiamond
    skinparam ConditionEndStyle hline
    start
    :接受 start 和 stop 位置参数;
    :current = head;
    :pos = 0;
    :newList = UnorderedList();
    while (pos<start and current 不为空) is (yes)
    floating note right:找到 start 位置的节点
        :pos += 1;
        :current = current._next;
    end while (no)
    if (current 为空) then(yes)
        :return False;   
        note left
            位置参数 start 不合理
        end note 
    else(no)
        :新节点 node = Node(current._value);
        :建立新节点的目的，是为了不影响原链表;
        :新链表的最后一个节点的 next 为 None;    
        :newList.head = node;
        :newCurrent = newList.head;
        :pos += 1;
        :current = current._next;
        while (pos<stop and current 不为空) is (yes)        
            :新节点 node = Node(current._value);
            :newCurrent._next = node;
            :newCurrent = node;
            :pos += 1;
            :current = current._next;
        end while (no)
        :return newList;
    endif
    end
    @enduml
```

### 1.4 代码
```python
def slice(self,start,stop=0):
	current = self.head
	pos = 0
	newList = UnorderedList()
	while pos<start and current:
		pos += 1
		current = current._next
	if current:
		node = Node(current._value)
		newList.head = node
		newCurrent = newList.head
		pos += 1
		current = current._next
		while pos<stop and current:
			node = Node(current._value)
			newCurrent._next = node
			newCurrent = node
			pos += 1
			current = current._next
		return newList
	else:
		return False
```

## 2 编程练习20
实现有序列表抽象数据类型剩余的方法

略

## 3 编程练习21

思考有序列表和无序列表的关系。实现继承结构
见[6.1 实现思路]({{< ref "/blog/第3章%20基本数据结构#6.1-实现思路" >}})

## 4 使用链表实现栈

```python
class Stack:
    def __init__(self):
        self._items = UnorderedList()
    
    def isEmpty(self):
        return self._items.isEmpty()

    def size(self):
        return self._items.length

    def push(self,item):
        self._items.add(item)

    def pop(self):
        self._items.pop()
```

## 5 使用链表实现队列

使用 UnorderedList_pro 类的原因，是因为该类添加了 rear 属性，使得 append 操作的时间复杂度为 O(1)。由于 pop(0)的时间复杂度为 O(1)，因此该方法实现的队列的 enqueue 操作和 dequeue 操作的时间复杂度均为 O(1)。

```python
class MyQueue:
    def __init__(self):
        self._items = UnorderedList_pro()

    def isEmpty(self):
        return self._items.isEmpty()

    def size(self):
        return self._items.length

    def enqueue(self,item):
        self._items.append(item)

    def dequeue(self):
        return self._items.pop()

    def __str__(self):
        return '{}'.format(self._items)
```

## 6 使用链表实现双端队列

```python
class Deque:
    def __init__(self):
        self._items = UnorderedList_pro()

    def isEmpty(self):
        return self._items.isEmpty()

    def size(self):
        return self._items.length

    def addFront(self,item):
        self._items.add(item)

    def addRear(self,item):
        self._items.append(item)

    def removeFront(self):
        return self._items.pop()
    
    def removeRear(self):
        rearIndex = self.size() -1
        return self._items.pop(rearIndex)

    def __str__(self):
        return '{}'.format(self._items)
```

## 7 设计和实现一个试验，比较用链表实现的列表与 Python 列表的性能

常用操作：

|  | 链表 |  | 列表 |  |
| --- | --- | --- | --- | --- |
|  | 操作方法 | 时间复杂度 | 操作方法 | 时间复杂度 |
| 取值 | ulist.slice(index) | O(n) | alist[index] | O(1) |
| 赋值 | ulist.assign(index,item) | O(n) | alist[index] = item | O(1) |
| 尾部添加 | ulist.append(item) | O(1) | alist.append(item) | O(1) |
| 尾部移除 | ulist.pop(index=ulist.size()-1) | O(n) | alist.pop() | O(1) |
| 头部移除 | ulist.pop() | O(1) | alist.pop(0) | O(n) |
| 插入 | ulist.insert(index,item) | O(n) | alist.insert(index,item) | O(n) |
| 删除 | ulist.remove(item) | O(n) | alist.remove(item) | O(n) |
| 切片 | ulist.slice(start,stop) | O(n) | alist[start:stop] | O(n) |

试验思路：分别构造 UnorderedList_pro 类 和 list 类的一个实例，依次执行尾部添加、插入、取值、赋值、pop、remove 等 6种操作，统计运行时间。

```python
def linklist_test(num):
    ulist = UnorderedList_pro()
    for i in range(num):
        ulist.append(i)
    for i in range(num):
        ulist.insert(i, i)
    for i in range(num):
        ulist.slice(i)
    for i in range(num):
        ulist.assign(i, 123)
    for i in range(num):
        ulist.pop()
    for i in range(num):
        ulist.remove(i)

def list_test(num):
    alist = []
    for i in range(num):        
        alist.append(i)
    for i in range(num):        
        alist.insert(i, i)
    for i in range(num):        
        alist[i]
    for i in range(num):        
        alist[i] = 123
    for i in range(num):        
        alist.pop()
    for i in range(num):        
        alist.remove(123)

import timeit

tt1 = timeit.Timer(stmt = "linklist_test(num)",setup = "from __main__ import linklist_test,num")
tt2 = timeit.Timer(stmt = "list_test(num)",setup = "from __main__ import list_test,num")
num = 1000
print(tt1.timeit(10))
print(tt2.timeit(10))
```

结果，链表的运行时间：2.445 秒，Python 列表的运行时间：0.013 秒。Python 列表的时间性能明显优于链表。

## 8 设计和实现一个试验，比较基于 Python 列表的栈和队列与相应链表实现的性能

## 9 栈

```python
def stack_test(stack):    
    for i in range(100000):
        stack.push(i)
    for i in range(100000):
        stack.pop()

tt = timeit.Timer(stmt="stack_test",setup="from __main__ import stack_test,stack")
#分别构造Python 列表的栈 stack = Stack() 和 链表实现的栈 stack = Stack()
print(tt.timeit(1000000))
```

Python 列表的栈运行时间：0.025 秒

链表实现的栈运行时间：0.031 秒

二者相当。

## 10 队列

```python
def queue_test(queue):
    for i in range(100000):
        queue.enqueue(i)
    for i in range(100000):
        queue.dequeue()

tt = timeit.Timer(stmt="queue_test",setup="from __main__ import queue_test,queue")
#分别构造Python 列表的队列 queue = MyQueue4(100) 和链表实现的队列 queue = MyQueue()
print(tt.timeit(1000000))
```

Python 列表的队列运行时间：0.024 秒

链表实现的队列运行时间：0.024 秒

二者相当。

## 11 用 Python 实现双向链表

```python
class Node:
    def __init__(self,item):
        self._value = item
        self._next = None
        self._pre = None

    def getValue(self):
        return self._value

    def getNext(self):
        return self._next

    def getPrevious(self):
        return self._pre

    def setValue(self,item):
        self._value = item

    def setNext(self,node):        
        self._next = node

    def setPrevious(self,node):
        self._pre = node

class DeLinkList:
    def __init__(self):
        self.head = None
        self.length = 0
        self.rear = None

    def isEmpty(self):
        return self.head == None

    def add(self,item):
        node = Node(item)
        if self.isEmpty():
            self.head=node
            self.rear = node
        else:
            current = self.head
            node.setNext(current)
            current.setPrevious(node)                        
            self.head = node
        self.length += 1
    
    def search(self,item):
        current = self.head
        founded = False
        while current and not founded:
            if current.getValue() == item:
                founded = True
            else:
                current = current.getNext()
        return founded

    def remove(self,item):
        current = self.head        
        founded = False
        while current:  #遍历链表
            if current.getValue() == item:  #找到值等于 item 的节点
                founded = True
                if not current.getPrevious():   #如果是头节点
                    self.head = current.getNext()
                    current = self.head                    
                else:
                    pre = current.getPrevious()
                    next = current.getNext()
                    pre.setNext(next)
                    current = next
                    if not next:    #如果不是列表尾
                        next.setPrevious(pre)
                    else:
                        self.rear=pre
                self.length -= 1
            else:                
                current = current.getNext()
        if not founded:
            return False               
        
    def append(self,item):
        node = Node(item)
        if self.rear:
            self.rear.setNext(node)
            node.setPrevious(self.rear)
            self.rear = node
        else:
            self.head = node
            self.rear = node
        self.length += 1

    def pop(self,index=None):  
        if not index:       #移除链表尾元素
            current = self.rear
            pre = current.getPrevious()
            pre.setNext(None)
            self.rear = pre
						self.length += 1
            return current.getValue()
        elif index == 0:    #移除链表头元素
            current  = self.head
            next = current.getNext()        
            self.head = next
            next.setPrevious(None)
						self.length += 1
            return current.getValue()
        else:
            return False    

    def __str__(self):
        result = []
        current = self.head
        while current:
            result.append(current.getValue())
            current = current.getNext()
        return "{}".format(result)
```

从上述代码可知，双向链表的节点中，因为既有向后的指针变量，，也有向前的指针变量，使得双向链表，不论是表头的添加、移除操作，还是表尾的添加、移除操作，其时间复杂度均为 O(1)。

## 12 为队列创建一个实现，使得添加操作和移除操作的平均时间复杂度是O(1)

见[23.使用链表实现队列](#23.使用链表实现队列)，另外，也可以使用双向链表来实现。

[3 直接的中序计算]({{< ref "/blog/第3章%20基本数据结构：编程练习#3-直接的中序计算" >}})