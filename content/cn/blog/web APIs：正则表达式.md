---
categories: JavaScript 入门到精通
title: web APIs：正则表达式
tags: [教程,JavaScript]
date: 2023-05-22
lastmod: 2023-05-25
thumbnail: 
published: "true"
slug: hi4kn98
---

>《JavaScript 入门到精通》读书笔记之十二

正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。这些模式被用于 RegExp 的 exec() 和 test() 方法，以及 String 的 match()、matchAll()、replace()、search() 和 split() 方法。详细语法参考[MDN Web Docs](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions)

## 1 创建正则表达式
### 1.1 方法一：使用正则表达式字面量
```js
const reg = /ab+c/;
```

### 1.2 方法二：调用RegExp对象的构造函数
```js
const reg = new RegExp("ab+c");
```

{{% alert title=提示 color=success %}}当需要获取正则表达式的长度，如关键词替换时，需要将关键词作相同长度的替换，此时则必须使用构造函数

 {{% /alert %}}### 1.3 实例
```js
const words = ['我们', '他们的', '你'];
area.addEventListener('blur', function () {
	// words.map(function (ele, index) {
	//     let reg = new RegExp(ele, 'g');
	//     input.value = input.value.replace(reg, '*'.repeat(ele.length));            
	// });
	for (let i = 0; i < words.length; i++) {
		let reg = new RegExp(words[i], 'g');
		this.value = this.value.replace(reg, '*'.repeat(words[i].length));
	}
});
```

## 2 JavaScript 中使用正则表达式

| 方法                                 | 描述                                                                                             |
| ------------------------------------ | ------------------------------------------------------------------------------------------------ |
| [exec()](#2.1-exec()%20方法)         | 字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）                        |
| [test()](#2.2-test()方法)            | 字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false                                         |
| [match()](#2.3-match()%20方法)       | 字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null                      |
| [matchAll()](#2.4-matchAll()%20方法) | 在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）                           |
| [search()](#2.5-search()%20方法)     | 在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回 -1                    |
| [replace()](#2.6-replace()%20方法)   | 在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串                   |
| split()                              | 使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 `String` 方法 |

### 2.1 exec() 方法

#### 2.1.1 语法
```js
const res = exec(str)
```

#### 2.1.2 参数
`str`：要匹配正则表达式的字符串

#### 2.1.3 返回值
如果匹配失败，exec() 方法返回 null，并将正则表达式的 lastIndex 重置为 0。
如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的 lastIndex 属性。完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应一个匹配的捕获组。数组还具有以下额外的属性：
- index：匹配到的字符位于原始字符串的基于 0 的索引值。
- input：匹配的原始字符串。
- groups：一个命名捕获组对象，其键是名称，值是捕获组。

#### 2.1.4 实例
exec() 的执行流程：
1. 获取需匹配的原始字符串 str
2. 创建正则表达式 regex，此时 regex 的属性 lastIndex 为 0
3. 从 lastIndex 开始执行 regex 的方法 exec(str)，得到返回值 arr
4. 如果匹配不成功，然后 arr = null，lastIndex = 0
5. 如果匹配成功，arr 得到一个数组，数组的第一项就是匹配成功的文本，该文本后面的索引值赋值给lastIndex，即下一次匹配的起始索引
6. 如果是循环，就从步骤 3 重复执行

因此，exec() 可用来对单个字符串中的多次匹配结果进行逐条的遍历（包括捕获到的匹配）。
```js
const regex = RegExp('foo*', 'g');
const str = 'table football, foosball';
let arr;
while ((arr = regex.exec(str)) !== null) {
  console.log(`Found ${arr[0]}. Next starts at ${regex.lastIndex}.`);
  // Expected output: "Found foo. Next starts at 9."
  // Expected output: "Found foo. Next starts at 19."
}
```

### 2.2 test()方法

#### 2.2.1 语法
```js
const res = regexObj.test(str)
```

#### 2.2.2 参数
`str`：需匹配的字符串

#### 2.2.3 返回值
如果正则表达式与指定的字符串匹配，返回`true`；否则`false`。

### 2.3 match() 方法

#### 2.3.1 语法
```js
str.match(regexp)
```

#### 2.3.2 参数
`regexp`：正则表达式对象

#### 2.3.3 返回值
-   如果使用 g 标志，则将返回与正则表达式匹配的所有结果，但不会返回捕获组。
-   如果未使用 g 标志，则仅返回第一个完整匹配及其相关的捕获组（`Array`）。在这种情况下，返回的项目将具有如下所述的其他属性。
	-   `groups`: 一个命名捕获组对象，其键是捕获组名称，值是捕获组，如果未定义命名捕获组，则为 `undefined`。
	-   `index`: 匹配的结果的开始位置
	-   `input`: 搜索的字符串。

### 2.4 matchAll() 方法

#### 2.4.1 语法
```js
str.matchAll(regexp)
```

#### 2.4.2 参数
`regexp`：正则表达式对象，必须设置全局模式 /g。

#### 2.4.3 返回值
一个迭代器，可以用 for-of 循环、展开语法等进行展开。

#### 2.4.4 实例
```js
const regexp = RegExp('foo[a-z]*', 'g');
        const str = 'table football, foosball';
        const matches = str.matchAll(regexp);  
        // 用 for-of 循环展开   
        for (const match of matches) {
            console.log(`Found ${match[0]} start=${match.index} end=${match.index + match[0].length}.`);
        }
	    // 用展开语法，得到的结果是一个数组
	    const newMatches = [...matches];       
```

### 2.5 search() 方法

#### 2.5.1 语法
```js
str.search(regexp)
```

#### 2.5.2 参数
`regexp`：正则表达式对象。

#### 2.5.3 返回值
如果匹配成功，则返回首次匹配项的索引;否则，返回 -1

### 2.6 replace() 方法

#### 2.6.1 语法
```js
str.replace(regexp|substr, newSubStr|function)
```

#### 2.6.2 参数
1. `regexp`：正则表达式对象。
2. `substr`：将被替换的字符串。仅第一个匹配项会被替换。
3. `newSubStr`：用于替换原字符串中的新字符串。
4. `function` ：用来创建新字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。

{{% alert title=提示 color=success %}}1. 在进行全局的搜索替换时，正则表达式需包含 `g` 标志。
2. 分组替换时，使用$1 、 $2 等代替替换文本

 {{% /alert %}}
#### 2.6.3 返回值
替换成功的新字符串

#### 2.6.4 实例
```js
let re = /apples/gi;
let str = "Apples are round, and apples are juicy.";
var newstr = str.replace(re, "oranges");
// 结果：oranges are round, and oranges are juicy.

// 分组替换
const re = /(\w+)\s(\w+)/;
const str = "John Smith";
const newstr = str.replace(re, "$2, $1");
console.log(newstr);
// Smith, John
```

### 2.7 split() 方法

## 3 常用的正则表达式

### 3.1 校验数字的表达式

1.数字：`^[0-9]*$`  
2.n位的数字：`^\d{n}$`  
3.至少n位的数字：`^\d{n,}$`  
4.m-n位的数字：`^\d{m,n}$`  
5.零和非零开头的数字：`^(0|[1-9][0-9]*)$`  
6.非零开头的最多带两位小数的数字：`^([1-9][0-9]*)+(.[0-9]{1,2})?$`  
7.带1-2位小数的正数或负数：`^(\-)?\d+(\.\d{1,2})?$`  
8.正数、负数、和小数：`^(\-|\+)?\d+(\.\d+)?$`  
9.有两位小数的正实数：`^[0-9]+(.[0-9]{2})?$`  
10.有1~3位小数的正实数：`^[0-9]+(.[0-9]{1,3})?$`  
11.非零的正整数：`^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$`  
12.非零的负整数：`^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$`  
13.非负整数：`^\d+$ 或 ^[1-9]\d*|0$`  
14.非正整数：`^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$`  
15.非负浮点数：`^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$`  
16.非正浮点数：`^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$`  
17.正浮点数：`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$`  
18.负浮点数：`^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`  
19.浮点数：`^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`

### 3.2 校验字符的表达式

1.汉字：`^[\u4e00-\u9fa5]{0,}$`  
2.英文和数字：`^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$`  
3.长度为3-20的所有字符：`^.{3,20}$`  
4.由26个英文字母组成的字符串：`^[A-Za-z]+$`  
5.由26个大写英文字母组成的字符串：`^[A-Z]+$`  
6.由26个小写英文字母组成的字符串：`^[a-z]+$`  
7.由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$`  
8.由数字、26个英文字母或者下划线组成的字符串：`^\w+$ 或 ^\w{3,20}$`  
9.中文、英文、数字包括下划线：`^[\u4E00-\u9FA5A-Za-z0-9_]+$`  
10.中文、英文、数字但不包括下划线等符号：`^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$`  
11.可以输入含有`^%&',;=?$"`等字符：`[^%&',;=?$\x22]+`  
12.禁止输入含有 `~` 的字符：`[^~\x22]+`

### 3.3 特殊需求表达式

1.Email地址：`^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$`  
2.域名：`[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?`  
3.InternetURL：`[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$`  
4.手机号码：`^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$`  
5.电话号码：`^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$`  
6.国内电话号码：`\d{3}-\d{8}|\d{4}-\d{7}`  
7.身份证号(15位、18位数字)：`^\d{15}|\d{18}$`  
8.短身份证号码(数字、字母x结尾)：`^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$`  
9.帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：`^[a-zA-Z][a-zA-Z0-9_]{4,15}$`  
10.密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：`^[a-zA-Z]\w{5,17}$`  
11.强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：`^(?=.*\d)(?=.*[a-z]({{< ref "/blog/?=.*[A-Z]).{8,10}$`  ，参考[密码的正则表达式](Python%20程序语言%20概论#1-密码的正则表达式" >}})
12.日期格式：`^\d{4}-\d{1,2}-\d{1,2}`  
13.一年的12个月(01～09和1～12)：`^(0?[1-9]|1[0-2])$`  
14.一个月的31天(01～09和1～31)：`^((0?[1-9])|((1|2)[0-9])|30|31)$`  
15.钱的输入格式：

-   有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：`^[1-9][0-9]*$`
-   这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：`^(0|[1-9][0-9]*)$`
-   一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：`^(0|-?[1-9][0-9]*)$`
-   这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：`^[0-9]+(.[0-9]+)?$`
-   必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：`^[0-9]+(.[0-9]{2})?$`
-   这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：`^[0-9]+(.[0-9]{1,2})?$`
-   这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：`^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$`
-   1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：`^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$`
-   备注：这就是最终结果了,别忘了"+"可以用"*"替代,如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里

16.xml文件：`^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$`  
17.中文字符的正则表达式：`[\u4e00-\u9fa5]`  
18.双字节字符`：[^\x00-\xff]` (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))  
19.空白行的正则表达式：`\n\s*\r` (可以用来删除空白行)  
20.HTML标记的正则表达式：`<(\S*?)[^>]*>.*?|<.*? />` 
21.首尾空白字符的正则表达式：`^\s*|\s*$或(^\s*)|(\s*$)` (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)  
22.腾讯QQ号：`[1-9][0-9]{4,}` (腾讯QQ号从10000开始)  
23.中国邮政编码：`[1-9]\d{5}(?!\d)` (中国邮政编码为6位数字)  
24.IP地址：`\d+\.\d+\.\d+\.\d+` (提取IP地址时有用)  
25.IP地址：`((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))`  
26.车牌
-   燃油车车牌:`^[\u4e00-\u9fa5]{1}[a-zA-Z]{1}[a-zA-Z_0-9]{4}[a-zA-Z_0-9_\u4e00-\u9fa5]$`
-   电动车车牌:`^[\u4e00-\u9fa5]{1}[a-zA-Z]{1}[a-zA-Z_0-9]{5}[a-zA-Z_0-9_\u4e00-\u9fa5]$`




